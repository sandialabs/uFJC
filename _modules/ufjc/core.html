<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ufjc.core &mdash; uFJC 1.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> uFJC
          </a>
              <div class="version">
                1.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../TUTORIAL.html">Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ufjc.core.html">ufjc.core module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ufjc.isometric.html">ufjc.isometric module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ufjc.isotensional.html">ufjc.isotensional module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ufjc.monte_carlo.html">ufjc.monte_carlo module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ufjc.potential.html">ufjc.potential module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ufjc.utility.html">ufjc.utility module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples.isotensional_approaches.html">examples.isotensional_approaches module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.isotensional_asymptotics.html">examples.isotensional_asymptotics module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tests</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tests.test_doc.html">tests.test_doc module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tests.test_style.html">tests.test_style module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">uFJC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>ufjc.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ufjc.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;The core module for the uFJC single-chain model.</span>

<span class="sd">This module consist of the class ``uFJC`` which, upon instantiation,</span>
<span class="sd">becomes a uFJC single-chain model instance with methods for computing</span>
<span class="sd">single-chain quantities in either thermodynamic ensemble.</span>

<span class="sd">Example:</span>
<span class="sd">    Import and create an instance of the model:</span>

<span class="sd">        &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">        &gt;&gt;&gt; model = uFJC()</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Import internal modules</span>
<span class="kn">from</span> <span class="nn">.isometric</span> <span class="k">import</span> <span class="n">uFJCIsometric</span>
<span class="kn">from</span> <span class="nn">.potential</span> <span class="k">import</span> <span class="n">Potential</span>

<span class="c1"># Import external modules</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">quad</span>


<div class="viewcode-block" id="uFJC"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC">[docs]</a><span class="k">class</span> <span class="nc">uFJC</span><span class="p">(</span><span class="n">Potential</span><span class="p">,</span> <span class="n">uFJCIsometric</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The uFJC single-chain model class.</span>

<span class="sd">    This class represents the uFJC single-chain model, meaning that an</span>
<span class="sd">    instance of this class is a uFJC single-chain model instance.</span>
<span class="sd">    It inherits all attributes and methods from the ``uFJCIsometric``</span>
<span class="sd">    class, which inherits all attributes and methods from the</span>
<span class="sd">    ``uFJCIsotensional`` class, which inherits all attributes and</span>
<span class="sd">    methods from the ``BasicUtility`` class.</span>
<span class="sd">    It also inherits a potential from the ``Potential`` class</span>
<span class="sd">    as the attribute ``pot``, a model instance itself.</span>
<span class="sd">    Keyword arguments are utilized during instantiation in order to</span>
<span class="sd">    specify model parameters; see the inherited classes and various examples</span>
<span class="sd">    through the documentation for more information.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        N_b (int): The number of links in the chain.</span>
<span class="sd">        k_0 (float): The initial reaction rate coefficient.</span>
<span class="sd">        init_config (np.ndarray): The initial configuration for Monte Carlo.</span>
<span class="sd">        c_kappa (float): The constant used for ideal/Gaussian approximations.</span>
<span class="sd">        nondim_P_eq_normalizations (dict): The normalizations for the</span>
<span class="sd">            nondimensional equilibrium distribution ``nondim_P_eq``</span>
<span class="sd">            for each approach.</span>
<span class="sd">        pot (object): The link potential model instance.</span>

<span class="sd">    Note:</span>
<span class="sd">        The attributes of a instantiated model should not be changed.</span>
<span class="sd">        There are several quantities that are computed and stored during</span>
<span class="sd">        instantiation that depend on these attributes and are not re-computed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the ``uFJC`` class,</span>
<span class="sd">        producing a uFJC single-chain model instance.</span>

<span class="sd">        First, initialize and inherit all attributes and methods</span>
<span class="sd">        from ``uFJCIsometric`` and ``Potential`` class instances;</span>
<span class="sd">        the latter assigns a potential (as attributes) to the model instance.</span>
<span class="sd">        Next, assign the attributes listed above.</span>
<span class="sd">        Then assign a default incremental link stretch function</span>
<span class="sd">        ``delta_lambda`` (inversion of ``eta_link``) if not already</span>
<span class="sd">        available from the potential choice.</span>
<span class="sd">        Also, adjust both ``delta_lambda`` and ``beta_u`` above</span>
<span class="sd">        ``eta_max`` and ``lambda_max``, if they exist for the potential,</span>
<span class="sd">        to prevent calculation errors.</span>
<span class="sd">        Finally, compute and store the normalization for ``nondim_P_eq``.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uFJCIsometric</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Potential</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get general single-chain model parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;N_b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;k_0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nondim_P_eq_normalizations</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Default initial configuration for Monte Carlo calculations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_config</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Constant for ideal/Gaussian approximations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_kappa</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Default to inverting eta(lambda) for the link if unavailable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;delta_lambda&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">eta</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">inv_fun_1D</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_link</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Prevent calculating bond stretch above a possible maximum force</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;eta_max&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__old_delta_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_lambda</span>

            <span class="c1"># Returns a high number above eta_max rather than calculating</span>
            <span class="k">def</span> <span class="nf">delta_lambda_safe</span><span class="p">(</span><span class="n">eta</span><span class="p">):</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_max</span>
                <span class="n">eta</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">delta_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__old_delta_lambda</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
                <span class="n">delta_lambda</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_exponent</span>
                <span class="k">return</span> <span class="n">delta_lambda</span>

            <span class="c1"># Replace the original function with this safe function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_lambda</span> <span class="o">=</span> <span class="n">delta_lambda_safe</span>

        <span class="c1"># Inhibit Monte Carlo sampling link stretches above lambda_max</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lambda_max&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__old_beta_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_u</span>

            <span class="c1"># Returns a prohibitively high number above lambda_max</span>
            <span class="k">def</span> <span class="nf">beta_u_safe</span><span class="p">(</span><span class="n">lambda_</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__old_beta_u</span><span class="p">(</span><span class="n">lambda_</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">maximum_exponent</span> <span class="o">*</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">heaviside</span><span class="p">(</span><span class="n">lambda_</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Replace the original function with this safe function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_u</span> <span class="o">=</span> <span class="n">beta_u_safe</span>

<div class="viewcode-block" id="uFJC.gamma"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC.gamma">[docs]</a>    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The nondimensional end-to-end length.</span>

<span class="sd">        This function computes the scalar nondimensional end-to-end length as a</span>
<span class="sd">        function of the scalar nondimensional force, :math:`\gamma(\eta)`.</span>
<span class="sd">        In the isotensional ensemble, it is given by</span>
<span class="sd">        :cite:`core-fiasconaro2019analytical`</span>

<span class="sd">        .. math::</span>
<span class="sd">            \gamma(\eta) = \frac{\partial}{\partial\eta}\,\ln\mathfrak{z}(\eta)</span>
<span class="sd">            ,</span>

<span class="sd">        where the single-link (since :math:`\gamma(\eta)` is independent of</span>
<span class="sd">        :math:`N_b` in the isotensional ensemble for the uFJC model)</span>
<span class="sd">        nondimensional isotensional partition function is given by</span>
<span class="sd">        :cite:`core-buche2022on`</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathfrak{z}(\eta) =</span>
<span class="sd">            4\pi\int \frac{\sinh(\lambda\eta)}{\lambda\eta} \,</span>
<span class="sd">            e^{-\varepsilon\phi(\lambda)} \, \lambda^2 d\lambda</span>
<span class="sd">            .</span>

<span class="sd">        This function is rarely exactly</span>
<span class="sd">        analytically available, is sometimes accurately approximated using</span>
<span class="sd">        analytically tractable asymptotic relations, and is otherwise</span>
<span class="sd">        numerically calculated using Monte Carlo or quadrature approaches.</span>
<span class="sd">        For the uFJC model, accurate asymptotic relations are available,</span>
<span class="sd">        and for the EFJC model (harmonic link potentials), it is actually</span>
<span class="sd">        possible to exactly find :math:`\gamma(\eta)` closed-form</span>
<span class="sd">        :cite:`core-balabaev2009extension`.</span>

<span class="sd">        Args:</span>
<span class="sd">            eta (array_like): The nondimensional force(s).</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The nondimensional end-to-end length(s).</span>

<span class="sd">        Examples:</span>
<span class="sd">            Create an EFJC model with a nondimensional link energy</span>
<span class="sd">            :math:`\varepsilon=23`, and calculate the nondimensional</span>
<span class="sd">            end-to-end length under an nondimensional force of 8</span>
<span class="sd">            using many of the available approaches:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;harmonic&#39;, varepsilon=23)</span>
<span class="sd">                &gt;&gt;&gt; model.gamma(8, approach=&#39;exact&#39;)</span>
<span class="sd">                array([1.25508427])</span>
<span class="sd">                &gt;&gt;&gt; model.gamma(8, approach=&#39;asymptotic&#39;)</span>
<span class="sd">                array([1.25508427])</span>
<span class="sd">                &gt;&gt;&gt; model.gamma(8, approach=&#39;reduced&#39;)</span>
<span class="sd">                array([1.22282631])</span>
<span class="sd">                &gt;&gt;&gt; model.gamma(8, approach=&#39;quadrature&#39;)</span>
<span class="sd">                array([1.25508427])</span>

<span class="sd">        Example:</span>
<span class="sd">            Verify that the ideal approximation is valid</span>
<span class="sd">            for small nondimensional forces:</span>

<span class="sd">                &gt;&gt;&gt; import numpy as np</span>
<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC()</span>
<span class="sd">                &gt;&gt;&gt; gamma_exact = model.gamma(1e-2, approach=&#39;exact&#39;)</span>
<span class="sd">                &gt;&gt;&gt; gamma_ideal = model.gamma(1e-2, ideal=True)</span>
<span class="sd">                &gt;&gt;&gt; np.isclose(gamma_exact, gamma_ideal)</span>
<span class="sd">                array([ True])</span>

<span class="sd">        Example:</span>
<span class="sd">            Verify that the single-chain mechanical response is the same</span>
<span class="sd">            in the isotensional ensemble as it is in the isometric ensemble</span>
<span class="sd">            when utilizing the Legendre transformation method:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;harmonic&#39;, varepsilon=23)</span>
<span class="sd">                &gt;&gt;&gt; eta = np.random.rand(88)</span>
<span class="sd">                &gt;&gt;&gt; (np.abs(model.gamma(eta, ensemble=&#39;isotensional&#39;) -</span>
<span class="sd">                ...         model.gamma(eta, ensemble=&#39;isometric&#39;,</span>
<span class="sd">                ...                     method=&#39;legendre&#39;)) &lt; 1e-6).all()</span>
<span class="sd">                True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ideal&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c_kappa</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ensemble&#39;</span><span class="p">,</span> <span class="s1">&#39;isotensional&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;isometric&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_isometric</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_isotensional</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="uFJC.eta"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC.eta">[docs]</a>    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The nondimensional force.</span>

<span class="sd">        This function computes the scalar nondimensional force as a function of</span>
<span class="sd">        the scalar nondimensional end-to-end length, :math:`\eta(\gamma)`.</span>
<span class="sd">        In the isometric ensemble, it is given by :cite:`core-manca2012elasticity`</span>

<span class="sd">        .. math::</span>
<span class="sd">            \gamma(\eta) = -\frac{1}{N_b}</span>
<span class="sd">            \frac{\partial}{\partial\gamma}</span>
<span class="sd">            \,\ln\mathfrak{Q}(\boldsymbol{\gamma})</span>
<span class="sd">            ,</span>

<span class="sd">        where the nondimensional isometric partition function is given by</span>
<span class="sd">        :cite:`core-buche2021fundamental`</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathfrak{Q}(\boldsymbol{\gamma}) =</span>
<span class="sd">            \iiint d^3\boldsymbol{\lambda}_1</span>
<span class="sd">            \,e^{-\varepsilon\phi(\lambda_1)} \cdots</span>
<span class="sd">            \iiint d^3\boldsymbol{\lambda}_{N_b}</span>
<span class="sd">            \,e^{-\varepsilon\phi(\lambda_{N_b})}</span>
<span class="sd">            ~\delta^3\left(\sum_{j=1}^{N_b}\boldsymbol{\lambda}_j</span>
<span class="sd">            - \boldsymbol{\gamma}\right)</span>
<span class="sd">            .</span>

<span class="sd">        This is analytically intractable for nearly all single-chain models,</span>
<span class="sd">        including the uFJC model. Fortunately, there are both exact numerical</span>
<span class="sd">        methods, such as Monte Carlo calculations, and accurate approximation</span>
<span class="sd">        methods, such as the Legendre transformation method which becomes</span>
<span class="sd">        valid relatively quickly as :math:`N_b` increases.</span>

<span class="sd">        Args:</span>
<span class="sd">            gamma (array_like): The nondimensional end-to-end length(s).</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The nondimensional force(s).</span>

<span class="sd">        Example:</span>
<span class="sd">            Compute the nondimensional force at an end-to-end length in the</span>
<span class="sd">            isometric ensemble, which (by default) is done using the Legendre</span>
<span class="sd">            transformation method and the asymptotic approach to get</span>
<span class="sd">            :math:`\gamma(\eta)` in the isotensional ensemble. Using the</span>
<span class="sd">            Legendre transformation method with a given isotensional approach</span>
<span class="sd">            for the isometric ensemble is equivalent to using the same approach</span>
<span class="sd">            in the isotensional ensemble:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;harmonic&#39;, varepsilon=23, N_b=8)</span>
<span class="sd">                &gt;&gt;&gt; model.eta(1.25508427, ensemble=&#39;isometric&#39;)</span>
<span class="sd">                array([8.00000001])</span>
<span class="sd">                &gt;&gt;&gt; model.eta(1.25508427, ensemble=&#39;isotensional&#39;)</span>
<span class="sd">                array([8.00000001])</span>

<span class="sd">        Example:</span>
<span class="sd">            Verify that the ideal approximation is valid for small</span>
<span class="sd">            nondimensional end-to-end lengths:</span>

<span class="sd">                &gt;&gt;&gt; import numpy as np</span>
<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC()</span>
<span class="sd">                &gt;&gt;&gt; eta_exact = model.eta(1e-2, approach=&#39;exact&#39;)</span>
<span class="sd">                &gt;&gt;&gt; eta_ideal = model.eta(1e-2, ideal=True)</span>
<span class="sd">                &gt;&gt;&gt; np.abs((eta_exact - eta_ideal)/eta_exact) &lt; 1e-3</span>
<span class="sd">                array([ True])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ideal&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c_kappa</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ensemble&#39;</span><span class="p">,</span> <span class="s1">&#39;isotensional&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;isometric&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_isometric</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_isotensional</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="uFJC.vartheta"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC.vartheta">[docs]</a>    <span class="k">def</span> <span class="nf">vartheta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The nondimensional Helmholtz free energy per link.</span>

<span class="sd">        This function compute the nondimensional Helmholtz free energy per link</span>
<span class="sd">        in the isometric ensemble, which is generally given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \vartheta(\boldsymbol{\gamma}) =</span>
<span class="sd">            -\ln\left[\mathfrak{Q}(\boldsymbol{\gamma})\right]^{1/N_b}</span>
<span class="sd">            .</span>

<span class="sd">        Args:</span>
<span class="sd">            gamma (array_like): The nondimensional end-to-end length(s).</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>
<span class="sd">                Passed to ``vartheta_isometric``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The nondimensional Helmholtz</span>
<span class="sd">            free energy(s) per link.</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a uFJC single-chain model with log-squared link potentials</span>
<span class="sd">            and calculate the Helmholtz free energy per link at</span>
<span class="sd">            a nondimensional end-to-end length of a half:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;log-squared&#39;)</span>
<span class="sd">                &gt;&gt;&gt; model.vartheta(0.5, method=&#39;legendre&#39;, approach=&#39;reduced&#39;)</span>
<span class="sd">                array([0.39097337])</span>

<span class="sd">        Example:</span>
<span class="sd">            Verify that the ideal approximation is valid for small</span>
<span class="sd">            nondimensional end-to-end lengths:</span>

<span class="sd">                &gt;&gt;&gt; import numpy as np</span>
<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC()</span>
<span class="sd">                &gt;&gt;&gt; vartheta = model.vartheta(1e-2, approach=&#39;reduced&#39;)</span>
<span class="sd">                &gt;&gt;&gt; vartheta_ideal = model.vartheta(1e-2, ideal=True)</span>
<span class="sd">                &gt;&gt;&gt; np.abs((vartheta - vartheta_ideal)/vartheta) &lt; 1e-1</span>
<span class="sd">                array([ True])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ideal&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c_kappa</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vartheta_isometric</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="uFJC.nondim_P_eq"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC.nondim_P_eq">[docs]</a>    <span class="k">def</span> <span class="nf">nondim_P_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The nondimensional equilibrium distribution function.</span>

<span class="sd">        This function computes the nondimensional probability density</span>
<span class="sd">        distribution of nondimensional end-to-end vectors at equilibrium,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathscr{P}_\mathrm{eq}(\boldsymbol{\gamma}) =</span>
<span class="sd">            \frac{e^{-N_b\,\vartheta(\boldsymbol{\gamma})}}</span>
<span class="sd">            {\iiint e^{-N_b\,\vartheta(\tilde{\boldsymbol{\gamma}})}</span>
<span class="sd">            \,d^3\tilde{\boldsymbol{\gamma}}}</span>
<span class="sd">            .</span>

<span class="sd">        Since the uFJC model is spherically-symmetric in</span>
<span class="sd">        :math:`\boldsymbol{\gamma}`,  ``nondim_P_eq`` is only a function</span>
<span class="sd">        of the scalar nondimensional end-to-end length :math:`\gamma`,</span>
<span class="sd">        and the normalization can be calculated</span>
<span class="sd">        using a one-dimensional integral over :math:`\gamma` instead</span>
<span class="sd">        :cite:`core-buche2020statistical`,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \iiint e^{-N_b\,\vartheta(\tilde{\boldsymbol{\gamma}})}</span>
<span class="sd">            \,d^3\tilde{\boldsymbol{\gamma}} =</span>
<span class="sd">            4\pi\int e^{-N_b\,\vartheta(\tilde{\gamma})}</span>
<span class="sd">            \,\tilde{\gamma}^2 d\tilde{\gamma}</span>
<span class="sd">            .</span>

<span class="sd">        The normalization for the distribution is computed for a given approach</span>
<span class="sd">        once the function is called using that approach.</span>

<span class="sd">        Args:</span>
<span class="sd">            gamma (array_like): The nondimensional end-to-end length(s).</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments. Passed to ``vartheta``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The nondimensional equilibrium</span>
<span class="sd">            probability density(s).</span>

<span class="sd">        Example:</span>
<span class="sd">            Evaluate the probability density at an end-to-end length of 0.23</span>
<span class="sd">            using two different approximation methods:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;morse&#39;, N_b=8)</span>
<span class="sd">                &gt;&gt;&gt; model.nondim_P_eq(23e-2)</span>
<span class="sd">                array([4.19686303])</span>
<span class="sd">                &gt;&gt;&gt; model.nondim_P_eq(23e-2, gaussian=True)</span>
<span class="sd">                array([3.86142625])</span>

<span class="sd">        Example:</span>
<span class="sd">            Verify that the probability density is normalized:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC()</span>
<span class="sd">                &gt;&gt;&gt; from scipy.integrate import quad</span>
<span class="sd">                &gt;&gt;&gt; integrand = lambda gamma: \</span>
<span class="sd">                ...     4*np.pi*gamma**2*model.nondim_P_eq(gamma)</span>
<span class="sd">                &gt;&gt;&gt; P_tot_eq = quad(integrand, 0, np.inf)[0]</span>
<span class="sd">                &gt;&gt;&gt; np.isclose(P_tot_eq, 1)</span>
<span class="sd">                True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">N_b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c_kappa</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># A variable string based on the approach</span>
            <span class="n">var_str</span> <span class="o">=</span> <span class="s1">&#39;nondim_P_eq_normalization_&#39;</span> <span class="o">+</span> \
                <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;approach&#39;</span><span class="p">,</span> <span class="s1">&#39;asymptotic&#39;</span><span class="p">))</span>

            <span class="c1"># Compute the normalization if not done already for the approach</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nondim_P_eq_normalizations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_str</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Set upper limit of integration</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lambda_max&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">upper_lim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_max</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">upper_lim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="c1"># Compute the normalzation and attribute it</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nondim_P_eq_normalizations</span><span class="p">[</span><span class="n">var_str</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">:</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">N_b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vartheta</span><span class="p">(</span><span class="n">gamma</span><span class="p">)),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">minimum_float</span><span class="p">,</span> <span class="n">upper_lim</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Return the nondimensional equilibrium probability density</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">N_b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vartheta</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="o">/</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">nondim_P_eq_normalizations</span><span class="p">[</span><span class="n">var_str</span><span class="p">]</span></div>

<div class="viewcode-block" id="uFJC.nondim_g_eq"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC.nondim_g_eq">[docs]</a>    <span class="k">def</span> <span class="nf">nondim_g_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The nondimensional equilibrium radial distribution function.</span>

<span class="sd">        This function computes the nondimensional radial probability density</span>
<span class="sd">        distribution of nondimensional end-to-end lengths at equilibrium,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathscr{g}_\mathrm{eq}(\gamma) =</span>
<span class="sd">            4\pi\gamma^2 \mathscr{P}_\mathrm{eq}(\gamma)</span>
<span class="sd">            .</span>

<span class="sd">        Args:</span>
<span class="sd">            gamma (array_like): The nondimensional end-to-end length(s).</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments. Passed to ``nondim_P_eq``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The nondimensional equilibrium radial</span>
<span class="sd">            probability density(s).</span>

<span class="sd">        Example:</span>
<span class="sd">            Verify that the function is normalized by integrating over all</span>
<span class="sd">            permissible end-to-end lengths, which in effect ensures that the</span>
<span class="sd">            total probability is unity:</span>

<span class="sd">                &gt;&gt;&gt; import numpy as np</span>
<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;morse&#39;)</span>
<span class="sd">                &gt;&gt;&gt; from scipy.integrate import quad</span>
<span class="sd">                &gt;&gt;&gt; P_tot_eq = quad(model.nondim_g_eq, 0, model.lambda_max)[0]</span>
<span class="sd">                &gt;&gt;&gt; np.isclose(P_tot_eq, 1)</span>
<span class="sd">                True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">nondim_P_eq</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="uFJC.k"><a class="viewcode-back" href="../../ufjc.core.html#ufjc.core.uFJC.k">[docs]</a>    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The net forward reaction rate coefficient function.</span>

<span class="sd">        This function computes the net forward reaction rate coefficient</span>
<span class="sd">        as a function of the nondimensional end-to-end length,</span>
<span class="sd">        i.e. :math:`k(\gamma)=N_bk&#39;(\gamma)`, where :math:`k&#39;(\gamma)` is the</span>
<span class="sd">        forward reaction rate coefficient function for a single link.</span>
<span class="sd">        This function is obtained using the axioms of transition state theory</span>
<span class="sd">        :cite:`core-zwanzig2001nonequilibrium`,</span>
<span class="sd">        and is currently implemented to use the Legendre transformation method</span>
<span class="sd">        and the reduced asymptotic approach</span>
<span class="sd">        :cite:`core-buche2021chain`.</span>

<span class="sd">        Args:</span>
<span class="sd">            gamma (array_like): The nondimensional end-to-end length(s).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The net forward reaction rate coefficient(s).</span>

<span class="sd">        Example:</span>
<span class="sd">            Compute the net forward reaction rate coefficients at several</span>
<span class="sd">            nondimensional end-to-end lengths:</span>

<span class="sd">                &gt;&gt;&gt; from ufjc import uFJC</span>
<span class="sd">                &gt;&gt;&gt; model = uFJC(potential=&#39;morse&#39;)</span>
<span class="sd">                &gt;&gt;&gt; model.k([0.8, 1.01, 1.6])</span>
<span class="sd">                array([6.23755528e-01, 9.80472713e-01, 6.59105919e+07])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute the corresponding force and link stretch</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
        <span class="n">lambda_</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_lambda</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>

        <span class="c1"># Compute the free energy barrier for a link, translated so k(0)=k_0</span>
        <span class="n">beta_delta_Psi_TS_single_link</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">varepsilon</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">lambda_</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lambda_max&#39;</span><span class="p">):</span>
            <span class="n">beta_delta_Psi_TS_single_link</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">log_over_sinh</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">log_over_sinh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_max</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">lambda_max</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_max</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span> <span class="o">+</span> \
                <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coth</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>

        <span class="c1"># Avoid overflow when returning the results</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_0</span><span class="p">)</span> <span class="o">-</span> <span class="n">beta_delta_Psi_TS_single_link</span>
        <span class="n">exponent</span><span class="p">[</span><span class="n">exponent</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_exponent</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_exponent</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 National Technology &amp; Engineering Solutions of Sandia,     LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS,     the U.S. Government retains certain rights in this software.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>